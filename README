Project by: John Kusner
Class: CSE241, Spring 2018

Building:
	Makefile is included, run
		$ make
	to build the project.

Executing:
	Run
		$ java -jar jjk320.jar
	Note that ojdbc7.jar is required for execution.

Data sources:
	- Names from edgar0 student and instructor tables
	- Other data generated by my Node.js code, available in this package

Info:
	This project is built out of many reususable parts. I tried to separate interfaces and sub-interfaces into
	their own files when it made sense. Most of the data retrieved from the database has its own class in the
	objects directory.

	The Java code is located in the com.johnkusner.cse241final package, which I will omit in the locations below.
	The Main class in the com.johnkusner.cse241final package is where the execution starts.
	The higher-level interfaces are located in the interfaces package.

Interfaces:
	Customer Interface:
		Class location: interfaces.customer.CustomerInterface
		Designed for: BRC customers
		Description:
			This is the highly interactive interface that most of my time went into. When you launch the
			interface you choose a user to login as. Then you are asked to choose one of that user's payment
			methods to use in the transaction. Next, you choose one of the user's addresses to ship to.
			This begins the online shopping interface described below.
		Sub-Interfaces:
			Shop On-Line:
				Class location: interfaces.customer.OnlineCustomerInterface
				This interface keeps track of the customer's shopping cart. It allows the user to add products
				to their cart, edit quantities of products in their cart, and checkout to complete the purchase.
				When the custom wants to add a product, they are given the choice of launching the Product Search
				or Category Browser interface. Once they have chosen a product to add, they are shown a listing
				for the availability of the product at its various prices in the BRC warehouses.
!!!! I HAVE TO FIGURE OUT HOW TO HANDLE MAX PRICE STILL !!!!
				The customer can choose the quantity they want to add to their cart, and repeat.
				The customer is able to view all of the items in their cart along with price totals. They are able
				to edit the quantity of items in their cart (and remove items) from this menu. If they search for
				a product that is already contained in their cart, they will be directed to this menu automatically.

				When the customer is ready to checkout, they confirm their decision and the purchase attempt begins.
				Auto commit is disabled, and several stored procedure calls are made at this time. If all of the
				products in a customer's cart have gone completely out of stock, the purchase is cancelled.
				Otherwise, if a least one item was able to be purchased, the purchase is considered a success, and
				the customer is alerted that the order was not entirely fulfilled if applicable.
				A transaction is added to the database, along with several entries into the purchased table for
				each product purchased. Entries are added to the online_transaction and shipped_order containing
				data based on the choices made after launching the interface. Auto commit is re-enabled after this
				process is complete.
			Product Search:
				Class location: interfaces.ProductSearchInterface
				This interface enables customers to search for products with a custom query. All special characters
				are removed from the input query and whitespace is trimmed. Before searching, the interface ensures
				that the query is at least 3 letters long and then runs a real query in the database.
				If there are multiple matching results, the user is asked which product they are interested in,
				otherwise they either taken directly to the one product found, or given a message that no matching
				items were found.
			Category Browser:
				Class location: interfaces.CategoryBrowser
				The category browser enables a customer to quickly find the product they are looking for in the
				product-category tree. The user is shown the current category, along with available subcategories
				to choose from. Once the user reaches a leaf in the category tree, they are shown the products
				in that category to choose from.
	
	Manager Interface:
		Class location: interfaces.manager.ManagerInterface
		Designed for: BRC managers
		Description:
		Sub-Interfaces:
			View Stores / Warehouses:
				Allows managers to view information about locations.
				Managers are able to view the inventory available at these locations, and can reorder chosen
				products from vendors in a few easy steps.
			View Customers:
				View information about customers, and their recent transactions.
			Transaction detail:
				This interface is launched by the Stores/Warehouses/Customers interfaces.
				It shows an overview of relevant transactions and allows you to choose a specific transaction
				to view additional details and all of the products sold in the transaction.
	
	Statistics Interface:
		Class location: interfaces.statistics.StatisticsInterface
		Designed for: BRC marketers, analysts, and statistitians
		Description:
			Provides a view of sales data over different time periods.
		Sub-Interfaces:
			Top product sales...:
				View the top selling products and associated sales-figures within the chosen time frame.
			Sales totals per...:
				View daily, weekly, monthly, or quarterly sales figures.
	
	In a real system. Several more interfaces would be included. These include price editing, sale and
	discount management, interfaces for cashiers that read barcodes and give live pricing information,
	interfaces for account management (both for the user and administrators), and many more.

Menus:
	Almost every inteface makes extensive use of paginated "Menu"s. The Menu class can be found in the root package.
	Entering a number [1-10] will start a sub-interface pertaining to that item, when applicable.
	Entering "n" will take you to the next page, and "p" will take you to the previous page.
	Entering "x" will close the Menu, when available.

Use of PL/SQL:
	Several PL/SQL procedures are used to enable product purchasing:
		- begin_transaction: Creates an empty transaction with the next available transaction id, returns the
			transaction_id to the caller via an out parameter.
		- purchase_product: purchases as many of a product as it can from either the specified location or the
			collection of all warehouses. Updates quantities in stock table and creates entries in the purchased
			table. Updates subtotal and total in the transaction table. Returns the amount of products purchased
			and the total price of the purchased products via out parameters.
		- finish_online_transaction: applies tax to a transaction (if asked), adds an entry to online_transaction
			table and either the pickup_order or shipped_order table. Also adds record to used_payment_method, as
			if a real customer used one of their payment methods to complete the transaction.
		- order_inventory: used within the Manager interface to order shipments of products to locations from
			vendors. This procedure will add an entry to the stock table, if one does not already exist. Otherwise,
			it will update the existing stock entry for that product and location.

Use of views:
	A handful of views exist. Most are for statistics purposes such as sales_totals_per_X, and top_selling_products_X.
	Additionally, warehouse_stock aggregates all available stock between warehouses, and store_transactions gets
	recent transaction information for a store including both physical and pickup_order transactions.
	
TODO:
	unify customer interfaces, make the difference that online requires login, offline requires you to pick store,
		stock information is dependent on if you are at a store or from the warehouses
	
!! average needs to change as cheaper products are purchased.
!! consider prompting user for their max price or max total
!! add order type to transaction view (optional column, ex: Pickup)